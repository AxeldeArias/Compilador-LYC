/*1ra Area: Código de Usuario*/
//---->Importaciones, paquetes
package Analizadores;
import java_cup.runtime.*;
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import Tabla.*;
import Arbol.*;
import java.util.Stack;

//-------> Codigo para el parser, variables, metodos

// ---------> Codigo para las acciones gramaticales
action code
{:
    Stack<Nodo> pilaExpresionIgualAFactor = new Stack<Nodo>();
    Stack<Nodo> pilaExpresionExpresion = new Stack<Nodo>();
    Stack<Nodo> pilaTerminoTermino = new Stack<Nodo>();

    public TablaDeSimbolos tablaDeSimbolos = new TablaDeSimbolos();
    public TipoDato tipoId;
    public Nodo nodoInicio, nodoPrograma, nodoBloque, nodoSentencia, 
               nodoAsignacion, nodoAsignacionEspecial, nodoExpresionLogica, nodoTerminoLogico,
               nodoExpresion, nodoTermino, nodoFactor;
:}


/*2da Area: Código de Usuario*/
//----------> declaracion de terminales


terminal String ID;
terminal String CONST_INT;
terminal String CONST_FLOAT;
terminal String CONST_STR;

terminal DEFVAR, ENDDEF;
terminal TIPO_INTEGER, TIPO_FLOAT;

terminal WHILE;
terminal IF, ELSE;
terminal OP_AND, OP_OR, OP_NOT;

terminal OP_ASIG;
terminal OP_SUMA, OP_RESTA;
terminal OP_MUL, OP_DIV;
terminal String OP_IGUAL, OP_DISTINTO;
terminal String OP_MENOR, OP_MENOR_IGUAL, OP_MAYOR, OP_MAYOR_IGUAL;
terminal String OP_ASIG_SUM, OP_ASIG_RES, OP_ASIG_MUL, OP_ASIG_DIV;
terminal LL_A, LL_C, P_A, P_C;
terminal PUNTO_COMA;
terminal DOS_PUNTOS;
terminal COMA;
terminal GET;
terminal DISPLAY;
                              

//----------> declaracion de no terminales
non terminal Symbol inicio, programa,
             seccion_declaraciones, bloque_declaraciones, declaracion,
             tipo_dato, lista_ids, bloque, sentencia, bloque_if, bloque_if_unario ,
             bloque_while, expresion_logica, termino_logico, asignacion ,
             asignacion_especial, expresion, termino,
             factor, escritura, lectura ;
non terminal String operadores_especiales, op_booleano;


//----------> precedencia de menor a mayor
// precedence left OP_SUMA, OP_RESTA;
// precedence left OP_MUL, OP_DIV;

start with inicio;


inicio   ::= programa {:
                            nodoInicio = nodoPrograma;
                            tablaDeSimbolos.recorrerTabla();
                            tablaDeSimbolos.guardarTabla();
                            System.out.println("Regla Compilacion OK");
                            if(nodoPrograma != null) nodoPrograma.recorrer();
                            if(nodoExpresionLogica != null) nodoExpresionLogica.recorrer();
                        :};

programa	::= seccion_declaraciones  bloque {: nodoPrograma = nodoBloque; :};

seccion_declaraciones 	::= DEFVAR bloque_declaraciones ENDDEF {: :};

bloque_declaraciones	::= declaracion
						| bloque_declaraciones declaracion  {: :}
						;

declaracion ::= tipo_dato DOS_PUNTOS lista_ids  {: :}
			;

tipo_dato 	::= TIPO_INTEGER {: tipoId = TipoDato.T_INTEGER; :}
			| TIPO_FLOAT {: tipoId = TipoDato.T_FLOAT; :}
			;

lista_ids	::= ID:_id {: tablaDeSimbolos.agregarEnTabla(_id, null, tipoId, null); :}
			| lista_ids PUNTO_COMA ID:_id {: tablaDeSimbolos.agregarEnTabla(_id, null, tipoId, null); :}
			;

bloque  ::= sentencia  {: nodoBloque = nodoSentencia; :}
		    | bloque sentencia {: nodoBloque = new Nodo("DELIMITADOR",nodoBloque, nodoSentencia); :}
		    ;

sentencia ::= asignacion {: nodoSentencia = nodoAsignacion; :}
			| asignacion_especial {: nodoSentencia = nodoAsignacionEspecial;:}
			| bloque_if
			| bloque_while
			| expresion
			| escritura
			| lectura
			;

bloque_if	::= IF P_A expresion_logica P_C LL_A bloque LL_C
			| IF P_A expresion_logica P_C LL_A bloque LL_C
				ELSE LL_A bloque LL_C
			;

bloque_if_unario	::= IF P_A expresion_logica COMA expresion COMA expresion P_C
                    ;

bloque_while    ::= WHILE P_A expresion_logica P_C LL_A bloque LL_C
				;

op_booleano 	::=  OP_MENOR: _opB {:RESULT=_opB; :}
				| OP_MENOR_IGUAL: _opB {:RESULT=_opB; :}
				| OP_MAYOR: _opB {:RESULT=_opB; :}
				| OP_MAYOR_IGUAL: _opB {:RESULT=_opB; :}
				| OP_IGUAL: _opB {: RESULT=_opB; :}
				| OP_DISTINTO: _opB {:RESULT=_opB; :}
				;

expresion_logica	::= termino_logico {: pilaTerminoTermino.push(nodoTerminoLogico); RESULT = new Symbol(-1); :}
                            OP_AND
                            termino_logico {: Nodo termPila =  pilaTerminoTermino.pop();
                                    nodoExpresionLogica = new Nodo("AND", termPila, nodoTerminoLogico) ;
                                :}
					| termino_logico OP_OR termino_logico
					| termino_logico
					|  OP_NOT termino_logico
					;

termino_logico	::= expresion {:
                                System.out.println("\t\tExpresion1: " + nodoExpresion);
                                pilaExpresionExpresion.push(nodoExpresion);
                                RESULT = new Symbol(-1);
                            :}
                        op_booleano: _operadorB
                        expresion {:
                            System.out.println("\t\tExpresion2: " + nodoExpresion);
                            Nodo expPila = pilaExpresionExpresion.pop();
                            nodoTerminoLogico = new Nodo(_operadorB, expPila,  nodoExpresion);
                        :}
                    ;
	

asignacion 	::= ID:_id OP_ASIG expresion {: 
					                tablaDeSimbolos.chequearEnTabla(_id);
                                    nodoAsignacion = new Nodo(":=", new Hoja(_id), nodoExpresion);
                                :}
			;

asignacion_especial ::= ID:_id operadores_especiales:_operador expresion  {: 
						tablaDeSimbolos.chequearEnTabla(_id);
						nodoAsignacionEspecial = new Nodo(_operador, new Hoja(_id), nodoExpresion);
					:}
					;
															
operadores_especiales   ::= OP_ASIG_SUM:_op {: RESULT=_op; :}
                        | OP_ASIG_RES:_op {: RESULT=_op; :}
                        | OP_ASIG_MUL:_op {: RESULT=_op; :}
                        | OP_ASIG_DIV:_op {: RESULT=_op; :}
						;

		
expresion	::= termino {: nodoExpresion = nodoTermino; :}
			| expresion OP_SUMA termino {: nodoExpresion = new Nodo("+",nodoExpresion, nodoTermino); :}
			| expresion OP_RESTA termino {: nodoExpresion = new Nodo("-",nodoExpresion, nodoTermino); :}
			| bloque_if_unario
			;

		
termino	::= termino OP_MUL factor {: nodoTermino = new Nodo("*",nodoTermino, nodoFactor); :}
		| termino OP_DIV factor  {: nodoTermino = new Nodo("/",nodoTermino, nodoFactor); :}
		| factor {: nodoTermino = nodoFactor; :}
		;
			
factor	::= P_A {:
            pilaExpresionIgualAFactor.push(nodoExpresion);
            pilaExpresionIgualAFactor.push(nodoTermino);
            RESULT = new Symbol(-1);
        :} expresion  P_C {:
            nodoFactor = nodoExpresion;
            nodoTermino = pilaExpresionIgualAFactor.pop();
            nodoExpresion= pilaExpresionIgualAFactor.pop();
            RESULT = new Symbol(-1);
        :}
		;

factor	::= ID:_id {:
            tablaDeSimbolos.chequearEnTabla(_id);
            nodoFactor = new Hoja(_id);
        :}
		| CONST_INT:_intVal {:
            tablaDeSimbolos.agregarEnTabla(null, _intVal, null, null);
            nodoFactor = new Hoja(_intVal);

		:}
		| CONST_FLOAT:_floatVal {: tablaDeSimbolos.agregarEnTabla(null, _floatVal, null, null);:}
		;

escritura	::= DISPLAY ID {: :}
			| DISPLAY CONST_STR:_strVal {: tablaDeSimbolos.agregarEnTabla(null, _strVal, null, _strVal.length());:}
			;

lectura	::= GET ID {: :}
		;
