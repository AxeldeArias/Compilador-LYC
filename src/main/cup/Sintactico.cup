/*1ra Area: Código de Usuario*/
//---->Importaciones, paquetes
package Analizadores;
import java_cup.runtime.*;
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import Tabla.*;
import Arbol.*;

//-------> Codigo para el parser, variables, metodos

// ---------> Codigo para las acciones gramaticales
action code
{:
    public TablaDeSimbolos tablaDeSimbolos = new TablaDeSimbolos();
    public TipoDato tipoId;
    public Nodo nodoInicio, nodoPrograma, nodoBloque, nodoSentencia, 
               nodoAsignacion, nodoAsignacionEspecial, 
               nodoExpresion, nodoTermino, nodoFactor;
:}


/*2da Area: Código de Usuario*/
//----------> declaracion de terminales


terminal String ID;
terminal String CONST_INT;
terminal String CONST_FLOAT;
terminal String CONST_STR;

terminal DEFVAR, ENDDEF;
terminal TIPO_INTEGER, TIPO_FLOAT;

terminal WHILE;
terminal IF, ELSE;
terminal OP_AND, OP_OR, OP_NOT;

terminal OP_ASIG;
terminal OP_SUMA, OP_RESTA;
terminal OP_MUL, OP_DIV;
terminal OP_IGUAL, OP_DISTINTO;
terminal OP_MENOR, OP_MENOR_IGUAL, OP_MAYOR, OP_MAYOR_IGUAL;
terminal OP_ASIG_SUM, OP_ASIG_RES, OP_ASIG_MUL, OP_ASIG_DIV;
terminal LL_A, LL_C, P_A, P_C;
terminal PUNTO_COMA;
terminal DOS_PUNTOS;
terminal COMA;
terminal GET;
terminal DISPLAY;
                              

//----------> declaracion de no terminales
non terminal inicio, programa;
non terminal seccion_declaraciones, bloque_declaraciones, declaracion;
non terminal tipo_dato, lista_ids, bloque, sentencia, bloque_if, bloque_if_unario ;
non terminal bloque_while, op_booleano, expresion_logica, termino_logico, asignacion ;
non terminal asignacion_especial, operadores_especiales, expresion, termino;
non terminal factor, escritura, lectura ;

//----------> precedencia de menor a mayor
// precedence left OP_SUMA, OP_RESTA;
// precedence left OP_MUL, OP_DIV;

start with inicio;


inicio   ::= programa {: nodoInicio = nodoPrograma; tablaDeSimbolos.recorrerTabla(); tablaDeSimbolos.guardarTabla(); System.out.println("Regla Compilacion OK"); nodoPrograma.recorrer();:};

programa	::= seccion_declaraciones bloque {: nodoPrograma = nodoBloque; :};

seccion_declaraciones 	::= DEFVAR bloque_declaraciones ENDDEF {: System.out.println("Regla SECCION DECLARACION");:};

bloque_declaraciones	::= declaracion
						| bloque_declaraciones declaracion  {: System.out.println("Regla BLOQUE DECLARACION");:}
						;

declaracion ::= tipo_dato DOS_PUNTOS lista_ids  {: System.out.println("Regla DECLARACION");:}
			;

tipo_dato 	::= TIPO_INTEGER {: tipoId = TipoDato.T_INTEGER;:}  {: System.out.println("Regla TIPO DECLARACION");:}
			| TIPO_FLOAT {: tipoId = TipoDato.T_FLOAT;:}  {: System.out.println("Regla TIPO DECLARACION");:}
			;

lista_ids	::= ID:_id {: tablaDeSimbolos.agregarEnTabla(_id, null, tipoId, null); System.out.println("Regla LISTA IDS");:}
			| lista_ids PUNTO_COMA ID:_id {: tablaDeSimbolos.agregarEnTabla(_id, null, tipoId, null); System.out.println("Regla LISTA IDS");:}
			;

bloque  ::= sentencia  {:nodoBloque = nodoSentencia; :}
		    | bloque sentencia {: nodoBloque = new Nodo("SEPARADOR",nodoBloque, nodoSentencia); :}
		    ;

sentencia ::= asignacion {: nodoSentencia = nodoAsignacion; :}
			| asignacion_especial {: nodoSentencia = nodoAsignacionEspecial;:}
			| bloque_if {: System.out.println("Regla SENTENCIA");:}
			| bloque_while {: System.out.println("Regla SENTENCIA");:}
			| expresion {: System.out.println("Regla SENTENCIA");:}
			| escritura {: System.out.println("Regla SENTENCIA");:}
			| lectura {: System.out.println("Regla SENTENCIA");:}
			;

bloque_if	::= IF P_A expresion_logica P_C LL_A bloque LL_C {: System.out.println("Regla BLOQUE_IF");:}
			| IF P_A expresion_logica P_C LL_A bloque LL_C
				ELSE LL_A bloque LL_C {: System.out.println("Regla BLOQUE IF ELSE");:}
			;

bloque_if_unario	::= IF P_A expresion_logica COMA expresion COMA expresion P_C {: System.out.println("Regla BLOQUE IF UNARIO");:};

bloque_while	::= WHILE P_A expresion_logica P_C LL_A bloque LL_C {: System.out.println("Regla BLOQUE_WHILE");:}
				;

op_booleano 	::= OP_MENOR
				| OP_MENOR_IGUAL
				| OP_MAYOR
				| OP_MAYOR_IGUAL
				| OP_IGUAL   
				| OP_DISTINTO
				;

expresion_logica	::= expresion_logica OP_AND termino_logico {: System.out.println("Regla EXPRESION_LOGICA");:}
					| expresion_logica OP_OR termino_logico {: System.out.println("Regla EXPRESION_LOGICA");:}
					| termino_logico {: System.out.println("Regla EXPRESION_LOGICA");:}
					;

termino_logico	::= OP_NOT termino_logico {: System.out.println("Regla TERMINO LOGICO");:}
				| expresion op_booleano expresion {: System.out.println("Regla TERMINO LOGICO");:}
				;
	

asignacion 	::= ID:_id OP_ASIG expresion {: 
					tablaDeSimbolos.chequearEnTabla(_id);
                    nodoAsignacion = new Nodo(":=", new Hoja(_id), nodoExpresion);
            :}
			;

asignacion_especial ::= ID:_id operadores_especiales:_operador expresion  {: 
						tablaDeSimbolos.chequearEnTabla(_id);
						nodoAsignacionEspecial = new Nodo(String.valueOf(_operador), new Hoja(_id), nodoExpresion);
					:}
					;
															
operadores_especiales   ::= OP_ASIG_SUM:_op {: RESULT=String.valueOf(_op); :}| OP_ASIG_RES:_op {: RESULT=String.valueOf(_op); :}| OP_ASIG_MUL:_op {: RESULT=String.valueOf(_op); :}| OP_ASIG_DIV:_op {: RESULT=String.valueOf(_op); :}
						;

		
expresion	::= termino {: nodoExpresion = nodoTermino; ;:}
			| expresion OP_SUMA termino {: nodoExpresion = new Nodo("+",nodoExpresion, nodoTermino); :}
			| expresion OP_RESTA termino {: nodoExpresion = new Nodo("-",nodoExpresion, nodoTermino); :}
			| bloque_if_unario
			;

		
termino	::= termino OP_MUL factor {: nodoTermino = new Nodo("*",nodoTermino, nodoFactor); :}
		| termino OP_DIV factor  {: nodoTermino = new Nodo("/",nodoTermino, nodoFactor); :}
		| factor {: nodoTermino = nodoFactor; :}
		;
			
factor	::= P_A expresion P_C {: nodoFactor = nodoExpresion; :}
		;

factor	::= ID:_id {:
            tablaDeSimbolos.chequearEnTabla(_id);
            nodoFactor = new Hoja(_id);
        :}
		| CONST_INT:_intVal {:
            tablaDeSimbolos.agregarEnTabla(null, _intVal, null, null);
            nodoFactor = new Hoja(_intVal);

		:}
		| CONST_FLOAT:_floatVal {: System.out.println(_floatVal); tablaDeSimbolos.agregarEnTabla(null, _floatVal, null, null);:}
		;

escritura	::= DISPLAY ID {: :}
			| DISPLAY CONST_STR:_strVal {: tablaDeSimbolos.agregarEnTabla(null, _strVal, null, _strVal.length());:}
			;

lectura	::= GET ID {: :}
		;
